import { TsconfigPathsPlugin } from '@esbuild-plugins/tsconfig-paths';
import esbuild from 'esbuild';
import { Lithia, Route } from 'lithia/types';
import path from 'node:path';
import { getOutputPath } from '../_utils';
import { ready, wait } from '../log';
import { green } from '../picocolors';
import { scanServerRoutes } from '../scan';
import { createRoutesManifest } from '../server';
import { printRoutesOverview } from './build';

/**
 * Builds the production server entry point.
 * @param {Lithia} lithia - The Lithia instance containing app configuration.
 * @returns {Promise<void>}
 */
async function buildServerEntryPoint(lithia: Lithia): Promise<void> {
  const entryPoint = path.join(import.meta.dirname, '..', 'server.js');
  const outputPath = path.resolve(process.cwd(), lithia.options.outputDir);

  await esbuild.build({
    entryPoints: [entryPoint],
    outdir: outputPath,
    platform: 'node',
    format: 'esm',
    packages: 'external',
    bundle: true,
    sourcemap: false,
    minify: true,
    keepNames: true,
    plugins: [
      TsconfigPathsPlugin({
        tsconfig: path.join(process.cwd(), 'tsconfig.json'),
      }),
    ],
    banner: {
      js: generateServerBanner(),
    },
  });
}

/**
 * Builds individual route files for production.
 * @param {Lithia} lithia - The Lithia instance containing app configuration.
 * @param {Route[]} routes - An array of route objects to be built.
 * @returns {Promise<void>}
 */
async function buildRouteFiles(lithia: Lithia, routes: Route[]): Promise<void> {
  await Promise.all(
    routes.map(async (route) => {
      const outputDir = path.dirname(getOutputPath(lithia, route.filePath));

      await esbuild.build({
        entryPoints: [route.filePath],
        bundle: true,
        outdir: outputDir,
        platform: 'node',
        format: 'esm',
        packages: 'external',
        sourcemap: false,
        minify: true,
        keepNames: false,
        splitting: false,
        plugins: [
          TsconfigPathsPlugin({
            tsconfig: path.join(process.cwd(), 'tsconfig.json'),
          }),
        ],
        banner: {
          js: generateRouteBanner(route),
        },
      });
    }),
  );
}

/**
 * Generates a banner comment for route files.
 * @param {Route} route - The route object containing metadata.
 * @returns {string} - A formatted banner comment.
 */
function generateRouteBanner(route: Route): string {
  return `
/**
 * @PROD
 * 
 * This file was generated by Lithia.
 * Do not edit this file directly.
 * 
 * Learn more at https://lithiajs.com
 * 
 * Route {
 *  env: ${route.env || 'all'}
 *  path: ${route.path}
 *  method: ${route.method || 'all'}
 *  dynamic: ${route.dynamic}
 * }
 * */
`;
}

/**
 * Generates a banner comment for the server entry point.
 * @returns {string} - A formatted banner comment.
 */
function generateServerBanner(): string {
  return `
/**
 * @PROD
 * 
 * This file was generated by Lithia.
 * Do not edit this file directly.
 * 
 * Learn more at https://lithiajs.com
 * 
 * */`;
}

/**
 * Builds the entire Lithia app for production.
 * @param {Lithia} lithia - The Lithia instance containing app configuration.
 * @returns {Promise<void>}
 */
export async function buildProd(lithia: Lithia): Promise<void> {
  try {
    wait('Building your Lithia app for production...');
    const routes = await scanServerRoutes(lithia);

    await Promise.all([
      buildServerEntryPoint(lithia),
      buildRouteFiles(lithia, routes),
    ]);

    await createRoutesManifest(lithia, routes);
    printRoutesOverview(routes);
    ready(
      `run: ${green('node ' + path.join(lithia.options.outputDir, 'server.js'))} to start your Lithia app in production mode.`,
    );
  } catch (error) {
    console.error('Error during production build:', error);
    process.exit(1);
  }
}
